/* automatically generated by rust-bindgen 0.55.1 */

pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const ATCA_POST_DELAY_MSEC: u32 = 25;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ATCA_BLOCK_SIZE: u32 = 32;
pub const ATCA_WORD_SIZE: u32 = 4;
pub const ATCA_PUB_KEY_PAD: u32 = 4;
pub const ATCA_SERIAL_NUM_SIZE: u32 = 9;
pub const ATCA_KEY_COUNT: u32 = 16;
pub const ATCA_ECC_CONFIG_SIZE: u32 = 128;
pub const ATCA_SHA_CONFIG_SIZE: u32 = 88;
pub const ATCA_OTP_SIZE: u32 = 64;
pub const ATCA_AES_GFM_SIZE: u32 = 32;
pub const ATCA_CHIPMODE_OFFSET: u32 = 19;
pub const ATCA_PUB_KEY_SIZE: u32 = 64;
pub const ATCA_PRIV_KEY_SIZE: u32 = 32;
pub const ATCA_SIG_SIZE: u32 = 64;
pub const ATCA_KEY_SIZE: u32 = 32;
pub const RSA2048_KEY_SIZE: u32 = 256;
pub const OUTNONCE_SIZE: u32 = 32;
pub const ATCA_COUNT_IDX: u32 = 0;
pub const ATCA_OPCODE_IDX: u32 = 1;
pub const ATCA_PARAM1_IDX: u32 = 2;
pub const ATCA_PARAM2_IDX: u32 = 3;
pub const ATCA_DATA_IDX: u32 = 5;
pub const ATCA_RSP_DATA_IDX: u32 = 1;
pub const ATCA_ADDRESS_MASK_CONFIG: u32 = 31;
pub const ATCA_ADDRESS_MASK_OTP: u32 = 15;
pub const ATCA_ADDRESS_MASK: u32 = 127;
pub const ATCA_TEMPKEY_KEYID: u32 = 65535;
pub const ATCA_B283_KEY_TYPE: u32 = 0;
pub const ATCA_K283_KEY_TYPE: u32 = 1;
pub const ATCA_P256_KEY_TYPE: u32 = 4;
pub const ATCA_AES_KEY_TYPE: u32 = 6;
pub const ATCA_SHA_KEY_TYPE: u32 = 7;
pub const AES_MODE_IDX: u32 = 2;
pub const AES_KEYID_IDX: u32 = 3;
pub const AES_INPUT_IDX: u32 = 5;
pub const AES_COUNT: u32 = 23;
pub const AES_MODE_KEY_BLOCK_POS: u32 = 6;
pub const AES_DATA_SIZE: u32 = 16;
pub const CHECKMAC_MODE_IDX: u32 = 2;
pub const CHECKMAC_KEYID_IDX: u32 = 3;
pub const CHECKMAC_CLIENT_CHALLENGE_IDX: u32 = 5;
pub const CHECKMAC_CLIENT_RESPONSE_IDX: u32 = 37;
pub const CHECKMAC_DATA_IDX: u32 = 69;
pub const CHECKMAC_COUNT: u32 = 84;
pub const CHECKMAC_CLIENT_CHALLENGE_SIZE: u32 = 32;
pub const CHECKMAC_CLIENT_RESPONSE_SIZE: u32 = 32;
pub const CHECKMAC_OTHER_DATA_SIZE: u32 = 13;
pub const CHECKMAC_CLIENT_COMMAND_SIZE: u32 = 4;
pub const CHECKMAC_CMD_MATCH: u32 = 0;
pub const CHECKMAC_CMD_MISMATCH: u32 = 1;
pub const COUNTER_MODE_IDX: u32 = 2;
pub const COUNTER_KEYID_IDX: u32 = 3;
pub const DERIVE_KEY_RANDOM_IDX: u32 = 2;
pub const DERIVE_KEY_TARGETKEY_IDX: u32 = 3;
pub const DERIVE_KEY_MAC_IDX: u32 = 5;
pub const DERIVE_KEY_COUNT_LARGE: u32 = 39;
pub const DERIVE_KEY_MAC_SIZE: u32 = 32;
pub const ECDH_KEY_SIZE: u32 = 32;
pub const GENDIG_ZONE_IDX: u32 = 2;
pub const GENDIG_KEYID_IDX: u32 = 3;
pub const GENDIG_DATA_IDX: u32 = 5;
pub const GENKEY_MODE_IDX: u32 = 2;
pub const GENKEY_KEYID_IDX: u32 = 3;
pub const GENKEY_DATA_IDX: u32 = 5;
pub const GENKEY_COUNT_DATA: u32 = 10;
pub const GENKEY_OTHER_DATA_SIZE: u32 = 3;
pub const HMAC_MODE_IDX: u32 = 2;
pub const HMAC_KEYID_IDX: u32 = 3;
pub const HMAC_DIGEST_SIZE: u32 = 32;
pub const INFO_PARAM1_IDX: u32 = 2;
pub const INFO_PARAM2_IDX: u32 = 3;
pub const KDF_MODE_IDX: u32 = 2;
pub const KDF_KEYID_IDX: u32 = 3;
pub const KDF_DETAILS_IDX: u32 = 5;
pub const KDF_DETAILS_SIZE: u32 = 4;
pub const KDF_MESSAGE_IDX: u32 = 9;
pub const LOCK_ZONE_IDX: u32 = 2;
pub const LOCK_SUMMARY_IDX: u32 = 3;
pub const LOCK_ZONE_MASK: u32 = 191;
pub const ATCA_UNLOCKED: u32 = 85;
pub const ATCA_LOCKED: u32 = 0;
pub const MAC_MODE_IDX: u32 = 2;
pub const MAC_KEYID_IDX: u32 = 3;
pub const MAC_CHALLENGE_IDX: u32 = 5;
pub const MAC_COUNT_LONG: u32 = 39;
pub const MAC_CHALLENGE_SIZE: u32 = 32;
pub const MAC_SIZE: u32 = 32;
pub const NONCE_MODE_IDX: u32 = 2;
pub const NONCE_PARAM2_IDX: u32 = 3;
pub const NONCE_INPUT_IDX: u32 = 5;
pub const NONCE_NUMIN_SIZE: u32 = 20;
pub const NONCE_NUMIN_SIZE_PASSTHROUGH: u32 = 32;
pub const PAUSE_SELECT_IDX: u32 = 2;
pub const PAUSE_PARAM2_IDX: u32 = 3;
pub const PRIVWRITE_ZONE_IDX: u32 = 2;
pub const PRIVWRITE_KEYID_IDX: u32 = 3;
pub const PRIVWRITE_VALUE_IDX: u32 = 5;
pub const PRIVWRITE_MAC_IDX: u32 = 41;
pub const PRIVWRITE_COUNT: u32 = 75;
pub const RANDOM_MODE_IDX: u32 = 2;
pub const RANDOM_PARAM2_IDX: u32 = 3;
pub const READ_ZONE_IDX: u32 = 2;
pub const READ_ADDR_IDX: u32 = 3;
pub const SECUREBOOT_MODE_IDX: u32 = 2;
pub const SECUREBOOT_DIGEST_SIZE: u32 = 32;
pub const SECUREBOOT_SIGNATURE_SIZE: u32 = 64;
pub const SECUREBOOT_MAC_SIZE: u32 = 32;
pub const SECUREBOOTCONFIG_OFFSET: u32 = 70;
pub const SELFTEST_MODE_IDX: u32 = 2;
pub const ATCA_SHA_DIGEST_SIZE: u32 = 32;
pub const SHA_DATA_MAX: u32 = 64;
pub const ATCA_SHA256_BLOCK_SIZE: u32 = 64;
pub const SHA_CONTEXT_MAX_SIZE: u32 = 99;
pub const SIGN_MODE_IDX: u32 = 2;
pub const SIGN_KEYID_IDX: u32 = 3;
pub const UPDATE_MODE_IDX: u32 = 2;
pub const UPDATE_VALUE_IDX: u32 = 3;
pub const VERIFY_MODE_IDX: u32 = 2;
pub const VERIFY_KEYID_IDX: u32 = 3;
pub const VERIFY_DATA_IDX: u32 = 5;
pub const VERIFY_256_STORED_COUNT: u32 = 71;
pub const VERIFY_283_STORED_COUNT: u32 = 79;
pub const VERIFY_256_VALIDATE_COUNT: u32 = 90;
pub const VERIFY_283_VALIDATE_COUNT: u32 = 98;
pub const VERIFY_256_EXTERNAL_COUNT: u32 = 135;
pub const VERIFY_283_EXTERNAL_COUNT: u32 = 151;
pub const VERIFY_256_KEY_SIZE: u32 = 64;
pub const VERIFY_283_KEY_SIZE: u32 = 72;
pub const VERIFY_256_SIGNATURE_SIZE: u32 = 64;
pub const VERIFY_283_SIGNATURE_SIZE: u32 = 72;
pub const VERIFY_OTHER_DATA_SIZE: u32 = 19;
pub const WRITE_ZONE_IDX: u32 = 2;
pub const WRITE_ADDR_IDX: u32 = 3;
pub const WRITE_VALUE_IDX: u32 = 5;
pub const WRITE_MAC_VS_IDX: u32 = 9;
pub const WRITE_MAC_VL_IDX: u32 = 37;
pub const WRITE_MAC_SIZE: u32 = 32;
pub const ATCA_SHA2_256_DIGEST_SIZE: u32 = 32;
pub const ATCA_AES_GCM_IV_STD_LENGTH: u32 = 12;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "!< Function succeeded."]
pub const ATCA_STATUS_ATCA_SUCCESS: ATCA_STATUS = 0;
pub const ATCA_STATUS_ATCA_CONFIG_ZONE_LOCKED: ATCA_STATUS = 1;
pub const ATCA_STATUS_ATCA_DATA_ZONE_LOCKED: ATCA_STATUS = 2;
#[doc = "!< response status byte indicates CheckMac failure (status byte = 0x01)"]
pub const ATCA_STATUS_ATCA_WAKE_FAILED: ATCA_STATUS = 208;
#[doc = "!< response status byte indicates CheckMac failure (status byte = 0x01)"]
pub const ATCA_STATUS_ATCA_CHECKMAC_VERIFY_FAILED: ATCA_STATUS = 209;
#[doc = "!< response status byte indicates parsing error (status byte = 0x03)"]
pub const ATCA_STATUS_ATCA_PARSE_ERROR: ATCA_STATUS = 210;
#[doc = "!< response status byte indicates DEVICE did not receive data properly (status byte = 0xFF)"]
pub const ATCA_STATUS_ATCA_STATUS_CRC: ATCA_STATUS = 212;
#[doc = "!< response status byte is unknown"]
pub const ATCA_STATUS_ATCA_STATUS_UNKNOWN: ATCA_STATUS = 213;
#[doc = "!< response status byte is ECC fault (status byte = 0x05)"]
pub const ATCA_STATUS_ATCA_STATUS_ECC: ATCA_STATUS = 214;
#[doc = "!< response status byte is Self Test Error, chip in failure mode (status byte = 0x07)"]
pub const ATCA_STATUS_ATCA_STATUS_SELFTEST_ERROR: ATCA_STATUS = 215;
#[doc = "!< Function could not execute due to incorrect condition / state."]
pub const ATCA_STATUS_ATCA_FUNC_FAIL: ATCA_STATUS = 224;
#[doc = "!< unspecified error"]
pub const ATCA_STATUS_ATCA_GEN_FAIL: ATCA_STATUS = 225;
#[doc = "!< bad argument (out of range, null pointer, etc.)"]
pub const ATCA_STATUS_ATCA_BAD_PARAM: ATCA_STATUS = 226;
#[doc = "!< invalid device id, id not set"]
pub const ATCA_STATUS_ATCA_INVALID_ID: ATCA_STATUS = 227;
#[doc = "!< Count value is out of range or greater than buffer size."]
pub const ATCA_STATUS_ATCA_INVALID_SIZE: ATCA_STATUS = 228;
#[doc = "!< CRC error in data received from device"]
pub const ATCA_STATUS_ATCA_RX_CRC_ERROR: ATCA_STATUS = 229;
#[doc = "!< Timed out while waiting for response. Number of bytes received is > 0."]
pub const ATCA_STATUS_ATCA_RX_FAIL: ATCA_STATUS = 230;
#[doc = "!< Not an error while the Command layer is polling for a command response."]
pub const ATCA_STATUS_ATCA_RX_NO_RESPONSE: ATCA_STATUS = 231;
#[doc = "!< Re-synchronization succeeded, but only after generating a Wake-up"]
pub const ATCA_STATUS_ATCA_RESYNC_WITH_WAKEUP: ATCA_STATUS = 232;
#[doc = "!< for protocols needing parity"]
pub const ATCA_STATUS_ATCA_PARITY_ERROR: ATCA_STATUS = 233;
#[doc = "!< for Microchip PHY protocol, timeout on transmission waiting for master"]
pub const ATCA_STATUS_ATCA_TX_TIMEOUT: ATCA_STATUS = 234;
#[doc = "!< for Microchip PHY protocol, timeout on receipt waiting for master"]
pub const ATCA_STATUS_ATCA_RX_TIMEOUT: ATCA_STATUS = 235;
#[doc = "!< Device did not respond too many times during a transmission. Could indicate no device present."]
pub const ATCA_STATUS_ATCA_TOO_MANY_COMM_RETRIES: ATCA_STATUS = 236;
#[doc = "!< Supplied buffer is too small for data required"]
pub const ATCA_STATUS_ATCA_SMALL_BUFFER: ATCA_STATUS = 237;
#[doc = "!< Communication with device failed. Same as in hardware dependent modules."]
pub const ATCA_STATUS_ATCA_COMM_FAIL: ATCA_STATUS = 240;
#[doc = "!< Timed out while waiting for response. Number of bytes received is 0."]
pub const ATCA_STATUS_ATCA_TIMEOUT: ATCA_STATUS = 241;
#[doc = "!< opcode is not supported by the device"]
pub const ATCA_STATUS_ATCA_BAD_OPCODE: ATCA_STATUS = 242;
#[doc = "!< received proper wake token"]
pub const ATCA_STATUS_ATCA_WAKE_SUCCESS: ATCA_STATUS = 243;
#[doc = "!< chip was in a state where it could not execute the command, response status byte indicates command execution error (status byte = 0x0F)"]
pub const ATCA_STATUS_ATCA_EXECUTION_ERROR: ATCA_STATUS = 244;
#[doc = "!< Function or some element of it hasn't been implemented yet"]
pub const ATCA_STATUS_ATCA_UNIMPLEMENTED: ATCA_STATUS = 245;
#[doc = "!< Code failed run-time consistency check"]
pub const ATCA_STATUS_ATCA_ASSERT_FAILURE: ATCA_STATUS = 246;
#[doc = "!< Failed to write"]
pub const ATCA_STATUS_ATCA_TX_FAIL: ATCA_STATUS = 247;
#[doc = "!< required zone was not locked"]
pub const ATCA_STATUS_ATCA_NOT_LOCKED: ATCA_STATUS = 248;
#[doc = "!< For protocols that support device discovery (kit protocol), no devices were found"]
pub const ATCA_STATUS_ATCA_NO_DEVICES: ATCA_STATUS = 249;
#[doc = "!< random number generator health test error"]
pub const ATCA_STATUS_ATCA_HEALTH_TEST_ERROR: ATCA_STATUS = 250;
#[doc = "!< Couldn't allocate required memory"]
pub const ATCA_STATUS_ATCA_ALLOC_FAILURE: ATCA_STATUS = 251;
#[doc = "!< Use flags on the device indicates its consumed fully"]
pub const ATCA_STATUS_ATCA_USE_FLAGS_CONSUMED: ATCA_STATUS = 252;
pub type ATCA_STATUS = ::std::os::raw::c_uint;
pub const ATCADeviceType_ATSHA204A: ATCADeviceType = 0;
pub const ATCADeviceType_ATECC108A: ATCADeviceType = 1;
pub const ATCADeviceType_ATECC508A: ATCADeviceType = 2;
pub const ATCADeviceType_ATECC608A: ATCADeviceType = 3;
pub const ATCADeviceType_ATSHA206A: ATCADeviceType = 4;
pub const ATCADeviceType_ATCA_DEV_UNKNOWN: ATCADeviceType = 32;
#[doc = " \\brief The supported Device type in Cryptoauthlib library"]
pub type ATCADeviceType = ::std::os::raw::c_uint;
#[doc = " \\brief atca_command is the C object backing ATCACommand."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_command {
    pub dt: ATCADeviceType,
    pub clock_divider: u8,
    pub execution_time_msec: u16,
}
#[test]
fn bindgen_test_layout_atca_command() {
    assert_eq!(
        ::std::mem::size_of::<atca_command>(),
        8usize,
        concat!("Size of: ", stringify!(atca_command))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_command>(),
        4usize,
        concat!("Alignment of ", stringify!(atca_command))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_command>())).dt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_command),
            "::",
            stringify!(dt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_command>())).clock_divider as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_command),
            "::",
            stringify!(clock_divider)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<atca_command>())).execution_time_msec as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_command),
            "::",
            stringify!(execution_time_msec)
        )
    );
}
pub type ATCACommand = *mut atca_command;
extern "C" {
    pub fn initATCACommand(device_type: ATCADeviceType, ca_cmd: ATCACommand) -> ATCA_STATUS;
}
extern "C" {
    pub fn newATCACommand(device_type: ATCADeviceType) -> ATCACommand;
}
extern "C" {
    pub fn deleteATCACommand(ca_cmd: *mut ATCACommand);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ATCAPacket {
    pub _reserved: u8,
    pub txsize: u8,
    pub opcode: u8,
    pub param1: u8,
    pub param2: u16,
    pub data: [u8; 192usize],
    pub execTime: u8,
}
#[test]
fn bindgen_test_layout_ATCAPacket() {
    assert_eq!(
        ::std::mem::size_of::<ATCAPacket>(),
        200usize,
        concat!("Size of: ", stringify!(ATCAPacket))
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAPacket>(),
        2usize,
        concat!("Alignment of ", stringify!(ATCAPacket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>()))._reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(_reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>())).txsize as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(txsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>())).opcode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>())).param1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(param1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>())).param2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(param2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>())).data as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAPacket>())).execTime as *const _ as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(execTime)
        )
    );
}
extern "C" {
    pub fn atCheckMAC(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atCounter(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atDeriveKey(ca_cmd: ATCACommand, packet: *mut ATCAPacket, has_mac: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atECDH(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atGenDig(
        ca_cmd: ATCACommand,
        packet: *mut ATCAPacket,
        is_no_mac_key: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atGenKey(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atHMAC(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atInfo(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atLock(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atMAC(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atNonce(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atPause(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atPrivWrite(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atRandom(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atRead(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSecureBoot(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSHA(
        ca_cmd: ATCACommand,
        packet: *mut ATCAPacket,
        write_context_size: u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSign(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atUpdateExtra(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atVerify(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atWrite(ca_cmd: ATCACommand, packet: *mut ATCAPacket, has_mac: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atAES(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSelfTest(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atKDF(ca_cmd: ATCACommand, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atIsSHAFamily(device_type: ATCADeviceType) -> bool;
}
extern "C" {
    pub fn atIsECCFamily(device_type: ATCADeviceType) -> bool;
}
extern "C" {
    pub fn isATCAError(data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atCRC(length: size_t, data: *const u8, crc_le: *mut u8);
}
extern "C" {
    pub fn atCalcCrc(pkt: *mut ATCAPacket);
}
extern "C" {
    pub fn atCheckCrc(response: *const u8) -> ATCA_STATUS;
}
pub const ATCAIfaceType_ATCA_I2C_IFACE: ATCAIfaceType = 0;
pub const ATCAIfaceType_ATCA_SWI_IFACE: ATCAIfaceType = 1;
pub const ATCAIfaceType_ATCA_UART_IFACE: ATCAIfaceType = 2;
pub const ATCAIfaceType_ATCA_SPI_IFACE: ATCAIfaceType = 3;
pub const ATCAIfaceType_ATCA_HID_IFACE: ATCAIfaceType = 4;
pub const ATCAIfaceType_ATCA_CUSTOM_IFACE: ATCAIfaceType = 5;
pub const ATCAIfaceType_ATCA_UNKNOWN_IFACE: ATCAIfaceType = 6;
pub type ATCAIfaceType = ::std::os::raw::c_uint;
pub const ATCAKitType_ATCA_KIT_AUTO_IFACE: ATCAKitType = 0;
pub const ATCAKitType_ATCA_KIT_I2C_IFACE: ATCAKitType = 1;
pub const ATCAKitType_ATCA_KIT_SWI_IFACE: ATCAKitType = 2;
pub const ATCAKitType_ATCA_KIT_UNKNOWN_IFACE: ATCAKitType = 3;
pub type ATCAKitType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ATCAIfaceCfg {
    pub iface_type: ATCAIfaceType,
    pub devtype: ATCADeviceType,
    pub __bindgen_anon_1: ATCAIfaceCfg__bindgen_ty_1,
    pub wake_delay: u16,
    pub rx_retries: ::std::os::raw::c_int,
    pub cfg_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ATCAIfaceCfg__bindgen_ty_1 {
    pub atcai2c: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1,
    pub atcaswi: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2,
    pub atcauart: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3,
    pub atcahid: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4,
    pub atcacustom: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1 {
    pub slave_address: u8,
    pub bus: u8,
    pub baud: u32,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>())).slave_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slave_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>())).bus as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>())).baud as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(baud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2 {
    pub bus: u8,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2>())).bus as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3 {
    pub port: ::std::os::raw::c_int,
    pub baud: u32,
    pub wordsize: u8,
    pub parity: u8,
    pub stopbits: u8,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>())).port as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>())).baud as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(baud)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>())).wordsize
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(wordsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>())).parity as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>())).stopbits
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(stopbits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4 {
    pub idx: ::std::os::raw::c_int,
    pub dev_interface: ATCAKitType,
    pub dev_identity: u8,
    pub vid: u32,
    pub pid: u32,
    pub packetsize: u32,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>())).idx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>())).dev_interface
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(dev_interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>())).dev_identity
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(dev_identity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>())).vid as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(vid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>())).pid as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>())).packetsize
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(packetsize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5 {
    pub halinit: ::std::option::Option<
        unsafe extern "C" fn(
            hal: *mut ::std::os::raw::c_void,
            cfg: *mut ::std::os::raw::c_void,
        ) -> ATCA_STATUS,
    >,
    pub halpostinit: ::std::option::Option<
        unsafe extern "C" fn(iface: *mut ::std::os::raw::c_void) -> ATCA_STATUS,
    >,
    pub halsend: ::std::option::Option<
        unsafe extern "C" fn(
            iface: *mut ::std::os::raw::c_void,
            txdata: *mut u8,
            txlength: ::std::os::raw::c_int,
        ) -> ATCA_STATUS,
    >,
    pub halreceive: ::std::option::Option<
        unsafe extern "C" fn(
            iface: *mut ::std::os::raw::c_void,
            rxdata: *mut u8,
            rxlength: *mut u16,
        ) -> ATCA_STATUS,
    >,
    pub halwake: ::std::option::Option<
        unsafe extern "C" fn(iface: *mut ::std::os::raw::c_void) -> ATCA_STATUS,
    >,
    pub halidle: ::std::option::Option<
        unsafe extern "C" fn(iface: *mut ::std::os::raw::c_void) -> ATCA_STATUS,
    >,
    pub halsleep: ::std::option::Option<
        unsafe extern "C" fn(iface: *mut ::std::os::raw::c_void) -> ATCA_STATUS,
    >,
    pub halrelease: ::std::option::Option<
        unsafe extern "C" fn(hal_data: *mut ::std::os::raw::c_void) -> ATCA_STATUS,
    >,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halinit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halinit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halpostinit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halpostinit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halsend as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halsend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halreceive
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halreceive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halwake as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halwake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halidle as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halidle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halsleep
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halsleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>())).halrelease
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(halrelease)
        )
    );
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(ATCAIfaceCfg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ATCAIfaceCfg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1>())).atcai2c as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcai2c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1>())).atcaswi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcaswi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1>())).atcauart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcauart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1>())).atcahid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcahid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ATCAIfaceCfg__bindgen_ty_1>())).atcacustom as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcacustom)
        )
    );
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg() {
    assert_eq!(
        ::std::mem::size_of::<ATCAIfaceCfg>(),
        88usize,
        concat!("Size of: ", stringify!(ATCAIfaceCfg))
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAIfaceCfg>(),
        8usize,
        concat!("Alignment of ", stringify!(ATCAIfaceCfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAIfaceCfg>())).iface_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(iface_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAIfaceCfg>())).devtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(devtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAIfaceCfg>())).wake_delay as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(wake_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAIfaceCfg>())).rx_retries as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(rx_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAIfaceCfg>())).cfg_data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(cfg_data)
        )
    );
}
pub type ATCAIface = *mut atca_iface;
#[doc = " \\brief atca_iface is the C object backing ATCAIface.  See the atca_iface.h file for"]
#[doc = " details on the ATCAIface methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_iface {
    pub mType: ATCAIfaceType,
    pub mIfaceCFG: *mut ATCAIfaceCfg,
    pub atinit: ::std::option::Option<
        unsafe extern "C" fn(
            hal: *mut ::std::os::raw::c_void,
            arg1: *mut ATCAIfaceCfg,
        ) -> ATCA_STATUS,
    >,
    pub atpostinit: ::std::option::Option<unsafe extern "C" fn(hal: ATCAIface) -> ATCA_STATUS>,
    pub atsend: ::std::option::Option<
        unsafe extern "C" fn(
            hal: ATCAIface,
            txdata: *mut u8,
            txlength: ::std::os::raw::c_int,
        ) -> ATCA_STATUS,
    >,
    pub atreceive: ::std::option::Option<
        unsafe extern "C" fn(hal: ATCAIface, rxdata: *mut u8, rxlength: *mut u16) -> ATCA_STATUS,
    >,
    pub atwake: ::std::option::Option<unsafe extern "C" fn(hal: ATCAIface) -> ATCA_STATUS>,
    pub atidle: ::std::option::Option<unsafe extern "C" fn(hal: ATCAIface) -> ATCA_STATUS>,
    pub atsleep: ::std::option::Option<unsafe extern "C" fn(hal: ATCAIface) -> ATCA_STATUS>,
    pub hal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_atca_iface() {
    assert_eq!(
        ::std::mem::size_of::<atca_iface>(),
        80usize,
        concat!("Size of: ", stringify!(atca_iface))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_iface>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_iface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).mType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(mType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).mIfaceCFG as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(mIfaceCFG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atinit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atpostinit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atpostinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atsend as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atsend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atreceive as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atreceive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atwake as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atwake)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atidle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).atsleep as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(atsleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_iface>())).hal_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(hal_data)
        )
    );
}
extern "C" {
    pub fn initATCAIface(cfg: *mut ATCAIfaceCfg, ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn newATCAIface(cfg: *mut ATCAIfaceCfg) -> ATCAIface;
}
extern "C" {
    pub fn releaseATCAIface(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn deleteATCAIface(ca_iface: *mut ATCAIface);
}
extern "C" {
    pub fn atinit(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atpostinit(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atsend(
        ca_iface: ATCAIface,
        txdata: *mut u8,
        txlength: ::std::os::raw::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atreceive(ca_iface: ATCAIface, rxdata: *mut u8, rxlength: *mut u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atwake(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atidle(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atsleep(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atgetifacecfg(ca_iface: ATCAIface) -> *mut ATCAIfaceCfg;
}
extern "C" {
    pub fn atgetifacehaldat(ca_iface: ATCAIface) -> *mut ::std::os::raw::c_void;
}
#[doc = " \\brief an intermediary data structure to allow the HAL layer to point the standard API functions"]
#[doc = "used by the upper layers to the HAL implementation for the interface.  This isolates the upper layers"]
#[doc = "and loosely couples the ATCAIface object from the physical implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAHAL_t {
    pub halinit: ::std::option::Option<
        unsafe extern "C" fn(
            hal: *mut ::std::os::raw::c_void,
            cfg: *mut ATCAIfaceCfg,
        ) -> ATCA_STATUS,
    >,
    pub halpostinit: ::std::option::Option<unsafe extern "C" fn(iface: ATCAIface) -> ATCA_STATUS>,
    pub halsend: ::std::option::Option<
        unsafe extern "C" fn(
            iface: ATCAIface,
            txdata: *mut u8,
            txlength: ::std::os::raw::c_int,
        ) -> ATCA_STATUS,
    >,
    pub halreceive: ::std::option::Option<
        unsafe extern "C" fn(iface: ATCAIface, rxdata: *mut u8, rxlength: *mut u16) -> ATCA_STATUS,
    >,
    pub halwake: ::std::option::Option<unsafe extern "C" fn(iface: ATCAIface) -> ATCA_STATUS>,
    pub halidle: ::std::option::Option<unsafe extern "C" fn(iface: ATCAIface) -> ATCA_STATUS>,
    pub halsleep: ::std::option::Option<unsafe extern "C" fn(iface: ATCAIface) -> ATCA_STATUS>,
    pub halrelease: ::std::option::Option<
        unsafe extern "C" fn(hal_data: *mut ::std::os::raw::c_void) -> ATCA_STATUS,
    >,
    pub hal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ATCAHAL_t() {
    assert_eq!(
        ::std::mem::size_of::<ATCAHAL_t>(),
        72usize,
        concat!("Size of: ", stringify!(ATCAHAL_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ATCAHAL_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ATCAHAL_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halinit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halpostinit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halpostinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halsend as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halsend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halreceive as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halreceive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halwake as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halwake)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halidle as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halidle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halsleep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halsleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).halrelease as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halrelease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ATCAHAL_t>())).hal_data as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(hal_data)
        )
    );
}
extern "C" {
    pub fn hal_iface_init(arg1: *mut ATCAIfaceCfg, hal: *mut ATCAHAL_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_iface_release(
        arg1: ATCAIfaceType,
        hal_data: *mut ::std::os::raw::c_void,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_check_wake(response: *const u8, response_size: ::std::os::raw::c_int)
        -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_init(hal: *mut ::std::os::raw::c_void, cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_post_init(iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_send(
        iface: ATCAIface,
        txdata: *mut u8,
        txlength: ::std::os::raw::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_receive(iface: ATCAIface, rxdata: *mut u8, rxlength: *mut u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_wake(iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_idle(iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_sleep(iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_release(hal_data: *mut ::std::os::raw::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_discover_buses(
        i2c_buses: *mut ::std::os::raw::c_int,
        max_buses: ::std::os::raw::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_i2c_discover_devices(
        bus_num: ::std::os::raw::c_int,
        cfg: *mut ATCAIfaceCfg,
        found: *mut ::std::os::raw::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atca_delay_ms(ms: u32);
}
extern "C" {
    pub fn atca_delay_us(us: u32);
}
extern "C" {
    #[doc = " \\brief Timer API implemented at the HAL level"]
    pub fn hal_rtos_delay_ms(ms: u32);
}
extern "C" {
    pub fn hal_delay_ms(ms: u32);
}
extern "C" {
    pub fn hal_delay_us(us: u32);
}
extern "C" {
    #[doc = " \\brief Optional hal interfaces"]
    pub fn hal_create_mutex(
        ppMutex: *mut *mut ::std::os::raw::c_void,
        pName: *mut ::std::os::raw::c_char,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_destroy_mutex(pMutex: *mut ::std::os::raw::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_lock_mutex(pMutex: *mut ::std::os::raw::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_unlock_mutex(pMutex: *mut ::std::os::raw::c_void) -> ATCA_STATUS;
}
#[doc = " \\brief atca_device is the C object backing ATCADevice.  See the"]
#[doc = "         atca_device.h file for details on the ATCADevice methods."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_device {
    #[doc = "!< Command set for a given CryptoAuth device"]
    pub mCommands: ATCACommand,
    #[doc = "!< Physical interface"]
    pub mIface: ATCAIface,
}
#[test]
fn bindgen_test_layout_atca_device() {
    assert_eq!(
        ::std::mem::size_of::<atca_device>(),
        16usize,
        concat!("Size of: ", stringify!(atca_device))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_device>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_device>())).mCommands as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(mCommands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_device>())).mIface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(mIface)
        )
    );
}
pub type ATCADevice = *mut atca_device;
extern "C" {
    pub fn initATCADevice(cfg: *mut ATCAIfaceCfg, cadev: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn newATCADevice(cfg: *mut ATCAIfaceCfg) -> ATCADevice;
}
extern "C" {
    pub fn releaseATCADevice(ca_dev: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn deleteATCADevice(ca_dev: *mut ATCADevice);
}
extern "C" {
    pub fn atGetCommands(dev: ATCADevice) -> ATCACommand;
}
extern "C" {
    pub fn atGetIFace(dev: ATCADevice) -> ATCAIface;
}
extern "C" {
    pub static mut cfg_ateccx08a_i2c_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_ateccx08a_swi_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_ateccx08a_kitcdc_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_ateccx08a_kithid_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_atsha20xa_i2c_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_atsha20xa_swi_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_atsha20xa_kitcdc_default: ATCAIfaceCfg;
}
extern "C" {
    pub static mut cfg_atsha20xa_kithid_default: ATCAIfaceCfg;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atcac_sha2_256_ctx {
    #[doc = "!< Filler value to make sure the actual implementation has enough room to store its context. uint32_t is used to remove some alignment warnings."]
    pub pad: [u32; 48usize],
}
#[test]
fn bindgen_test_layout_atcac_sha2_256_ctx() {
    assert_eq!(
        ::std::mem::size_of::<atcac_sha2_256_ctx>(),
        192usize,
        concat!("Size of: ", stringify!(atcac_sha2_256_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<atcac_sha2_256_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atcac_sha2_256_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atcac_sha2_256_ctx>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atcac_sha2_256_ctx),
            "::",
            stringify!(pad)
        )
    );
}
extern "C" {
    pub fn atcac_sw_sha2_256_init(ctx: *mut atcac_sha2_256_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atcac_sw_sha2_256_update(
        ctx: *mut atcac_sha2_256_ctx,
        data: *const u8,
        data_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atcac_sw_sha2_256_finish(
        ctx: *mut atcac_sha2_256_ctx,
        digest: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atcac_sw_sha2_256(
        data: *const u8,
        data_size: size_t,
        digest: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _gDevice: ATCADevice;
}
extern "C" {
    pub fn atcab_version(ver_str: *mut ::std::os::raw::c_char) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_init(cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_init_device(ca_device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_release() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_device() -> ATCADevice;
}
extern "C" {
    pub fn atcab_get_device_type() -> ATCADeviceType;
}
extern "C" {
    pub fn _atcab_exit() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_wakeup() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_idle() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sleep() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_cfg_discover(
        cfg_array: *mut ATCAIfaceCfg,
        max: ::std::os::raw::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_addr(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        addr: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_zone_size(zone: u8, slot: u16, size: *mut size_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes(mode: u8, key_id: u16, aes_in: *const u8, aes_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_encrypt(
        key_id: u16,
        key_block: u8,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_decrypt(
        key_id: u16,
        key_block: u8,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gfm(h: *const u8, input: *const u8, output: *mut u8) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_cbc_ctx {
    #[doc = "!< Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey."]
    pub key_id: u16,
    #[doc = "!< Index of the 16-byte block to use within the key location for the actual key."]
    pub key_block: u8,
    #[doc = "!< Ciphertext from last operation."]
    pub ciphertext: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_atca_aes_cbc_ctx() {
    assert_eq!(
        ::std::mem::size_of::<atca_aes_cbc_ctx>(),
        20usize,
        concat!("Size of: ", stringify!(atca_aes_cbc_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_aes_cbc_ctx>(),
        2usize,
        concat!("Alignment of ", stringify!(atca_aes_cbc_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_cbc_ctx>())).key_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_cbc_ctx>())).key_block as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(key_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_cbc_ctx>())).ciphertext as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(ciphertext)
        )
    );
}
pub type atca_aes_cbc_ctx_t = atca_aes_cbc_ctx;
extern "C" {
    pub fn atcab_aes_cbc_init(
        ctx: *mut atca_aes_cbc_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_encrypt_block(
        ctx: *mut atca_aes_cbc_ctx_t,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_decrypt_block(
        ctx: *mut atca_aes_cbc_ctx_t,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_cmac_ctx {
    #[doc = "!< CBC context"]
    pub cbc_ctx: atca_aes_cbc_ctx_t,
    #[doc = "!< Number of bytes in current block."]
    pub block_size: u32,
    #[doc = "!< Unprocessed message storage."]
    pub block: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_atca_aes_cmac_ctx() {
    assert_eq!(
        ::std::mem::size_of::<atca_aes_cmac_ctx>(),
        40usize,
        concat!("Size of: ", stringify!(atca_aes_cmac_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_aes_cmac_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atca_aes_cmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_cmac_ctx>())).cbc_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cmac_ctx),
            "::",
            stringify!(cbc_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_cmac_ctx>())).block_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cmac_ctx),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_cmac_ctx>())).block as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cmac_ctx),
            "::",
            stringify!(block)
        )
    );
}
pub type atca_aes_cmac_ctx_t = atca_aes_cmac_ctx;
extern "C" {
    pub fn atcab_aes_cmac_init(
        ctx: *mut atca_aes_cmac_ctx_t,
        key_id: u16,
        key_block: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cmac_update(
        ctx: *mut atca_aes_cmac_ctx_t,
        data: *const u8,
        data_size: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cmac_finish(
        ctx: *mut atca_aes_cmac_ctx_t,
        cmac: *mut u8,
        cmac_size: u32,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_ctr_ctx {
    #[doc = "!< Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey."]
    pub key_id: u16,
    #[doc = "!< Index of the 16-byte block to use within the key location for the actual key."]
    pub key_block: u8,
    #[doc = "!< Counter block, comprises of nonce + count value (16 bytes)."]
    pub cb: [u8; 16usize],
    #[doc = "!< Size of counter in the initialization vector."]
    pub counter_size: u8,
}
#[test]
fn bindgen_test_layout_atca_aes_ctr_ctx() {
    assert_eq!(
        ::std::mem::size_of::<atca_aes_ctr_ctx>(),
        20usize,
        concat!("Size of: ", stringify!(atca_aes_ctr_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_aes_ctr_ctx>(),
        2usize,
        concat!("Alignment of ", stringify!(atca_aes_ctr_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_ctr_ctx>())).key_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_ctr_ctx>())).key_block as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(key_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_ctr_ctx>())).cb as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_aes_ctr_ctx>())).counter_size as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(counter_size)
        )
    );
}
pub type atca_aes_ctr_ctx_t = atca_aes_ctr_ctx;
extern "C" {
    pub fn atcab_aes_ctr_init(
        ctx: *mut atca_aes_ctr_ctx_t,
        key_id: u16,
        key_block: u8,
        counter_size: u8,
        iv: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_init_rand(
        ctx: *mut atca_aes_ctr_ctx_t,
        key_id: u16,
        key_block: u8,
        counter_size: u8,
        iv: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_block(
        ctx: *mut atca_aes_ctr_ctx_t,
        input: *const u8,
        output: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_encrypt_block(
        ctx: *mut atca_aes_ctr_ctx_t,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_decrypt_block(
        ctx: *mut atca_aes_ctr_ctx_t,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_increment(ctx: *mut atca_aes_ctr_ctx_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_checkmac(
        mode: u8,
        key_id: u16,
        challenge: *const u8,
        response: *const u8,
        other_data: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_counter(mode: u8, counter_id: u16, counter_value: *mut u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_counter_increment(counter_id: u16, counter_value: *mut u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_counter_read(counter_id: u16, counter_value: *mut u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_derivekey(mode: u8, key_id: u16, mac: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_base(
        mode: u8,
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        out_nonce: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh(key_id: u16, public_key: *const u8, pms: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_enc(
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        read_key: *const u8,
        read_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_ioenc(
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        io_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_tempkey(public_key: *const u8, pms: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_tempkey_ioenc(
        public_key: *const u8,
        pms: *mut u8,
        io_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_gendig(
        zone: u8,
        key_id: u16,
        other_data: *const u8,
        other_data_size: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_genkey_base(
        mode: u8,
        key_id: u16,
        other_data: *const u8,
        public_key: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_genkey(key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_pubkey(key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hmac(mode: u8, key_id: u16, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_base(mode: u8, param2: u16, out_data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info(revision: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_set_latch(state: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_get_latch(state: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_kdf(
        mode: u8,
        key_id: u16,
        details: u32,
        message: *const u8,
        out_data: *mut u8,
        out_nonce: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock(mode: u8, summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_config_zone() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_config_zone_crc(summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_zone() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_zone_crc(summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_slot(slot: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_mac(mode: u8, key_id: u16, challenge: *const u8, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_base(
        mode: u8,
        zero: u16,
        num_in: *const u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce(num_in: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_load(target: u8, num_in: *const u8, num_in_size: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_rand(num_in: *const u8, rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_challenge(num_in: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_challenge_seed_update(num_in: *const u8, rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_priv_write(
        key_id: u16,
        priv_key: *const u8,
        write_key_id: u16,
        write_key: *const u8,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_random(rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_zone(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *mut u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_locked(zone: u8, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_slot_locked(slot: u16, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_bytes_zone(
        zone: u8,
        slot: u16,
        offset: size_t,
        data: *mut u8,
        length: size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_serial_number(serial_number: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_pubkey(slot: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_sig(slot: u16, sig: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_config_zone(config_data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_cmp_config_zone(config_data: *mut u8, same_config: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_enc(
        key_id: u16,
        block: u8,
        data: *mut u8,
        enc_key: *const u8,
        enc_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_secureboot(
        mode: u8,
        param2: u16,
        digest: *const u8,
        signature: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_secureboot_mac(
        mode: u8,
        digest: *const u8,
        signature: *const u8,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_selftest(mode: u8, param2: u16, result: *mut u8) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atca_sha256_ctx {
    #[doc = "!< Total number of message bytes processed"]
    pub total_msg_size: u32,
    #[doc = "!< Number of bytes in current block"]
    pub block_size: u32,
    #[doc = "!< Unprocessed message storage"]
    pub block: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_atca_sha256_ctx() {
    assert_eq!(
        ::std::mem::size_of::<atca_sha256_ctx>(),
        136usize,
        concat!("Size of: ", stringify!(atca_sha256_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<atca_sha256_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atca_sha256_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_sha256_ctx>())).total_msg_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_sha256_ctx),
            "::",
            stringify!(total_msg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_sha256_ctx>())).block_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_sha256_ctx),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atca_sha256_ctx>())).block as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_sha256_ctx),
            "::",
            stringify!(block)
        )
    );
}
pub type atca_sha256_ctx_t = atca_sha256_ctx;
pub type atca_hmac_sha256_ctx_t = atca_sha256_ctx_t;
extern "C" {
    pub fn atcab_sha_base(
        mode: u8,
        length: u16,
        data_in: *const u8,
        data_out: *mut u8,
        data_out_size: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_start() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_update(message: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_end(digest: *mut u8, length: u16, message: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_read_context(context: *mut u8, context_size: *mut u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_write_context(context: *const u8, context_size: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha(length: u16, message: *const u8, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256(data: *const u8, data_size: size_t, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256_init(ctx: *mut atca_sha256_ctx_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256_update(
        ctx: *mut atca_sha256_ctx_t,
        data: *const u8,
        data_size: size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256_finish(ctx: *mut atca_sha256_ctx_t, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_init(ctx: *mut atca_hmac_sha256_ctx_t, key_slot: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_update(
        ctx: *mut atca_hmac_sha256_ctx_t,
        data: *const u8,
        data_size: size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_finish(
        ctx: *mut atca_hmac_sha256_ctx_t,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac(
        data: *const u8,
        data_size: size_t,
        key_slot: u16,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign_base(mode: u8, key_id: u16, signature: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign(key_id: u16, msg: *const u8, signature: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign_internal(
        key_id: u16,
        is_invalidate: bool,
        is_full_sn: bool,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_updateextra(mode: u8, new_value: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify(
        mode: u8,
        key_id: u16,
        signature: *const u8,
        public_key: *const u8,
        other_data: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_extern(
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_extern_mac(
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_stored(
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_stored_mac(
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_validate(
        key_id: u16,
        signature: *const u8,
        other_data: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_invalidate(
        key_id: u16,
        signature: *const u8,
        other_data: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write(zone: u8, address: u16, value: *const u8, mac: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_zone(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *const u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_bytes_zone(
        zone: u8,
        slot: u16,
        offset_bytes: size_t,
        data: *const u8,
        length: size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_pubkey(slot: u16, public_key: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_config_zone(config_data: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_enc(
        key_id: u16,
        block: u8,
        data: *const u8,
        enc_key: *const u8,
        enc_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_config_counter(counter_id: u16, counter_value: u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_printbin(binary: *mut u8, bin_len: size_t, add_space: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_bin2hex(
        bin: *const u8,
        bin_size: size_t,
        hex: *mut ::std::os::raw::c_char,
        hex_size: *mut size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_bin2hex_(
        bin: *const u8,
        bin_size: size_t,
        hex: *mut ::std::os::raw::c_char,
        hex_size: *mut size_t,
        is_pretty: bool,
        is_space: bool,
        is_upper: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hex2bin(
        ascii_hex: *const ::std::os::raw::c_char,
        ascii_hex_len: size_t,
        binary: *mut u8,
        bin_len: *mut size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hex2bin_(
        hex: *const ::std::os::raw::c_char,
        hex_size: size_t,
        bin: *mut u8,
        bin_size: *mut size_t,
        is_space: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_printbin_sp(binary: *mut u8, bin_len: size_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_printbin_label(
        label: *const ::std::os::raw::c_char,
        binary: *mut u8,
        bin_len: size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn packHex(
        ascii_hex: *const ::std::os::raw::c_char,
        ascii_hex_len: size_t,
        packed_hex: *mut ::std::os::raw::c_char,
        packed_len: *mut size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn isDigit(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn isWhiteSpace(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn isAlpha(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn isHexAlpha(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn isHex(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn isHexDigit(c: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn isBase64(c: ::std::os::raw::c_char, rules: *const u8) -> bool;
}
extern "C" {
    pub fn isBase64Digit(c: ::std::os::raw::c_char, rules: *const u8) -> bool;
}
extern "C" {
    pub fn base64Index(c: ::std::os::raw::c_char, rules: *const u8) -> u8;
}
extern "C" {
    pub fn base64Char(id: u8, rules: *const u8) -> ::std::os::raw::c_char;
}
extern "C" {
    pub static mut atcab_b64rules_default: [u8; 4usize];
}
extern "C" {
    pub static mut atcab_b64rules_mime: [u8; 4usize];
}
extern "C" {
    pub static mut atcab_b64rules_urlsafe: [u8; 4usize];
}
extern "C" {
    pub fn atcab_base64decode_(
        encoded: *const ::std::os::raw::c_char,
        encoded_size: size_t,
        data: *mut u8,
        data_size: *mut size_t,
        rules: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_base64decode(
        encoded: *const ::std::os::raw::c_char,
        encoded_size: size_t,
        data: *mut u8,
        data_size: *mut size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_base64encode_(
        data: *const u8,
        data_size: size_t,
        encoded: *mut ::std::os::raw::c_char,
        encoded_size: *mut size_t,
        rules: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_base64encode(
        data: *const u8,
        data_size: size_t,
        encoded: *mut ::std::os::raw::c_char,
        encoded_size: *mut size_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_reversal(
        bin: *const u8,
        bin_size: size_t,
        dest: *mut u8,
        dest_size: *mut size_t,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
